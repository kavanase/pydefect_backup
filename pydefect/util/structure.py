# -*- coding: utf-8 -*-
from pydefect.database.atom import symbols_to_atom
from pydefect.util.math import normalized_random_3d_vector, random_vector
from pymatgen import Structure

__author__ = "Yu Kumagai"
__copyright__ = "Copyright 2018, Oba group"
__version__ = "0.1"
__maintainer__ = "Yu Kumagai"
__email__ = "yuuukuma@gmail.com"
__status__ = "Development"
__date__ = "April 4, 2018"


def structure_to_spglib_cell(s):
    """
    Constructs a tuple of lattice parameters, atomic positions in fractional
    coordinates, and corresponding atomic numbers to be parsed by spglib.
    Args:
        s (Structure):
    """
    lattice = s.lattice.lll_matrix.tolist()
    positions = s.frac_coords.tolist()
    atomic_numbers = [i.specie.number for i in s.sites]
    return lattice, positions, atomic_numbers


def spglib_cell_to_structure(cell):
    species = [symbols_to_atom[i] for i in cell[2]]
    return Structure(cell[0], species, cell[1])


def find_primitive(s):

    import spglib
    cell = structure_to_spglib_cell(s)
    return spglib_cell_to_structure(spglib.find_primitive(cell))


def structure2seekpath(s, time_reversal=True, ref_distance=0.025):
    """
    Returns the full information for band path generated by seekpath.
    Args:
        s (Structure):
        time_reversal (bool): If the time reversal symmetry exists
        ref_distance (float): distance for the k-point mesh.
    """
    import seekpath
    cell = structure_to_spglib_cell(s)
    res = seekpath.get_explicit_k_path(cell,
                                       with_time_reversal=time_reversal,
                                       reference_distance=ref_distance,
                                       recipe='hpkot',
                                       threshold=1.e-7,
                                       symprec=1e-05,
                                       angle_tolerance=-1.0)
    from pymatgen.analysis.structure_matcher import StructureMatcher

    sm = StructureMatcher(ltol=0.0001, stol=0.0001, angle_tol=0.001,
                          primitive_cell=False, scale=False)

#    print(sm.fit(s, seekpath2structure(res)))
    if sm.fit(s, seekpath2structure(res)):
        return res
    else:
        raise NotStandardizedPrimitiveError


def seekpath2structure(res):
    lattice = res["primitive_lattice"]
    element_types = res["primitive_types"]
    species = [symbols_to_atom[i] for i in element_types]
    positions = res["primitive_positions"]
    return Structure(lattice, species, positions)


def perturb_neighbors(structure, center, cutoff, distance):
    """
    Randomly perturbs atoms around an input point in a structure.

    Args:
        structure (Structure): pmg Structure/IStructure class object
        center (3x1 array): Fractional coordinates of a central position.
        cutoff (float): Radius of a sphere in which atoms are perturbed [A].
        distance (float): Max distance for the perturbation [A].
    """
    if type(center) == list and len(center) == 3:
        cartesian_coords = structure.lattice.get_cartesian_coords(center)
        neighbors = structure.get_sites_in_sphere(
            cartesian_coords, cutoff, include_index=True)
    else:
        raise ValueError

    sites = []
    # Since translate_sites accepts only one vector, we need to iterate this.
    for i in neighbors:
        vector = random_vector(normalized_random_3d_vector(), distance)
        site = i[2]
        sites.append(site)
        structure.translate_sites(site, vector, frac_coords=False)

    return structure, sites


class NotStandardizedPrimitiveError(Exception):
    pass